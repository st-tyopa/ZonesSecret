--*****************************************************
-- Блочный конструктор диалогов.
-- copyright © Zander, 2013 - 2015
--*****************************************************

local dialog_ids = {}
local sizeof_ids = 1
local ltx = system_ini()
local v4
local def_0, def_none = 0, -1
local init_complete = false
local act_npc_phrases = {}
local act_npc_control_status = true

function init()
	if script_server_object_version() < 7 then v4 = true
	else def_0, def_none = "0", ""	-- id для 1.0006 - строки
	v4 = false
	end
	if not din_functions_dlg then
		_G.din_functions_dlg = {}
	end
	init_complete = true
end

function dia(key_id)
if dialog_ids[key_id] ~= nil then
	return dialog_ids[key_id]
else
	if v4 then
		dialog_ids[key_id] = sizeof_ids
	else
		dialog_ids[key_id] = tostring(sizeof_ids)
	end
	sizeof_ids = sizeof_ids + 1
	return dialog_ids[key_id]
end
end

function diaclear()
local a = 1
local t = {}
for k, v in pairs(dialog_ids) do
	if v ~= nil then table.insert(t, k) end
end
while t[a] ~= nil do
	local kk = t[a]
	dialog_ids[kk] = nil
a = a + 1
end
dialog_ids = {}
sizeof_ids = 1
end

function string_uncompress(ammo_list,border_symbol)
	if ammo_list and border_symbol and type(ammo_list) == "string" and type(border_symbol) == "string" then

	local pos = string.find(ammo_list,border_symbol,1)
	local ammo_return = {}
	local a = 1
	local spos = 1
	if pos ~= nil then
		while pos ~= nil do
		ammo_return[a] = string.sub(ammo_list, spos, pos - 1)
		spos = pos + 1
		pos = string.find(ammo_list, border_symbol, spos)
		a = a + 1
		end
		ammo_return[a] = string.sub(ammo_list, spos, string.len(ammo_list))
	else
	ammo_return[a] = ammo_list
	end
	return ammo_return  
	else 
	log1("string_uncompress: Called incorrect")
	
	return ammo_list 
	end
end

function get_actor_params()
	return {
		pos = db.actor:position(),
		lv = db.actor:level_vertex_id(),
		gv = db.actor:game_vertex_id(),
		id = db.actor:id()
	}
end

function items_calc(sec)
	local t = {}
	local iia = function(actor, item)
		if item and item:section() == sec then
			table.insert(t, item:id())
		end
	end
	if db.actor then db.actor:iterate_inventory(iia, actor) end
	return t
end

function exist_script_and_func(adres, sec, line)
	--printf(string.format("exist_script_and_func %s", adres))
	local st = assembly_dialogs.string_uncompress(adres, "%.")
	if st[1] and st[2] then
		local a = st[1]
		local b = st[2]
		if _G[a] then
			if _G[a][b] then
				if type(_G[a][b]) ~= 'function' then
					log1(string.format("Dialog %s; line %i: value %s.%s - not function", sec, line, a, b))
					abort(string.format("Dialog %s; line %i: value %s.%s - not function", sec, line, a, b))
				end
			else
				log1(string.format("Dialog %s; line %i: function %s.%s not exist", sec, line, a, b))
				abort(string.format("Dialog %s; line %i: function %s.%s not exist", sec, line, a, b))
			end
		else
			log1(string.format("Dialog %s; line %i: script file %s is nil", sec, line, a))
			abort(string.format("Dialog %s; line %i: script file %s is nil", sec, line, a))
		end
	else
		log1("Dialog %s; line %i: Некорректный формат вызова функции", sec, line)
		abort("Dialog %s; line %i: Некорректный формат вызова функции", sec, line)
	end
end

function assembly_phrase(r_sec, r_k, phr_tbl, phr_k, dlg, assign_key, input_key)
	--printf(string.format("assembly_phrase %s, index %i, out: %s; in^ %s", r_sec, r_k, assign_key, input_key or "nil"))
	local ik = nil
	if input_key then ik = dia(input_key)
	else ik = def_0 end
	local self_phr_key = assembly_dialogs.dia(assign_key)
	assembly_dialogs.act_npc_control_system(self_phr_key, ik, r_sec, r_k)
	phr_tbl[phr_k] = dlg:AddPhrase(ltx:r_string(r_sec, "x"..tostring(r_k)), self_phr_key, ik, -10000):GetPhraseScript()
		if ltx:line_exist(r_sec, "a"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "a"..tostring(r_k)) 
			local act_arg = assembly_dialogs.string_uncompress(act_s, ",")
		--	local act_arg = zander_utils.read_strings(r_sec, "a"..tostring(r_k), nil)
			if type(act_arg) == "table" then
				local aa = 1
				while act_arg[aa] ~= nil do
					assembly_dialogs.exist_script_and_func(act_arg[aa], r_sec, r_k)
					phr_tbl[phr_k]:AddAction(act_arg[aa])
					aa = aa + 1
				end
			elseif type(act_arg) == "string" then
				assembly_dialogs.exist_script_and_func(act_arg, r_sec, r_k)
				phr_tbl[phr_k]:AddAction(act_arg)
			else
			 --- uncompatible types. Error.
			end
		end
		if ltx:line_exist(r_sec, "p"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "p"..tostring(r_k)) 
			--zander_log("p1;", act_s)
			local act_arg = assembly_dialogs.string_uncompress(act_s, ",")
			--zander_log("p2;", act_arg)
			if type(act_arg) == "table" then
				local ab = 1
				while act_arg[ab] ~= nil and act_arg[ab] ~= "" do
					assembly_dialogs.exist_script_and_func(act_arg[ab], r_sec, r_k)
					phr_tbl[phr_k]:AddPrecondition(act_arg[ab])
					ab = ab + 1
				end
			elseif type(act_arg) == "string" and act_arg ~= "" then
				assembly_dialogs.exist_script_and_func(act_arg, r_sec, r_k)
				phr_tbl[phr_k]:AddPrecondition(act_arg)
			else
			 --- uncompatible types. Error.
			end
		end
		if ltx:line_exist(r_sec, "h"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "h"..tostring(r_k)) 
			local act_arg = assembly_dialogs.string_uncompress(act_s, ",")
			if type(act_arg) == "table" then
				local ac = 1
				while act_arg[ac] ~= nil do
					--assembly_dialogs.exist_script_and_func(act_arg[ac])
					phr_tbl[phr_k]:AddHasInfo(act_arg[ac])
					ac = ac + 1
				end
			elseif type(act_arg) == "string" then
				--assembly_dialogs.exist_script_and_func(act_arg)
				phr_tbl[phr_k]:AddHasInfo(act_arg)
			else
			 --- uncompatible types. Error.
			end
		end
		if ltx:line_exist(r_sec, "d"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "d"..tostring(r_k)) 
			local act_arg = assembly_dialogs.string_uncompress(act_s, ",")
			if type(act_arg) == "table" then
				local ad = 1
				while act_arg[ad] ~= nil do
					--assembly_dialogs.exist_script_and_func(act_arg[ad])
					phr_tbl[phr_k]:AddDontHasInfo(act_arg[ad])
					ad = ad + 1
				end
			elseif type(act_arg) == "string" then
				--assembly_dialogs.exist_script_and_func(act_arg)
				phr_tbl[phr_k]:AddDontHasInfo(act_arg)
			else
			 --- uncompatible types. Error.
			end
		end
		if ltx:line_exist(r_sec, "gi"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "gi"..tostring(r_k)) 
			local act_arg = assembly_dialogs.string_uncompress(act_s, ",")
			if type(act_arg) == "table" then
				local ae = 1
				while act_arg[ae] ~= nil do
					--assembly_dialogs.exist_script_and_func(act_arg[ae])
					phr_tbl[phr_k]:AddGiveInfo(act_arg[ae])
					ae = ae + 1
				end
			elseif type(act_arg) == "string" then
				--assembly_dialogs.exist_script_and_func(act_arg)
				phr_tbl[phr_k]:AddGiveInfo(act_arg)
			else
			 --- uncompatible types. Error.
			end
		end
		if ltx:line_exist(r_sec, "di"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "di"..tostring(r_k)) 
			local act_arg = assembly_dialogs.string_uncompress(act_s, ",")
			if type(act_arg) == "table" then
				local af = 1
				while act_arg[af] ~= nil do
					--assembly_dialogs.exist_script_and_func(act_arg[af])
					phr_tbl[phr_k]:AddDisafleInfo(act_arg[af])
					af = af + 1
				end
			elseif type(act_arg) == "string" then
				--assembly_dialogs.exist_script_and_func(act_arg)
				phr_tbl[phr_k]:AddDisableInfo(act_arg)
			else
			 --- uncompatible types. Error.
			end
		end
		if ltx:line_exist(r_sec, "item"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "item"..tostring(r_k)) 
			local act_it = assembly_dialogs.string_uncompress(act_s, ",")
			local ag = 1
			local sub_tbl = {}
			while act_it[ag] ~= nil do
				local act_arg = assembly_dialogs.string_uncompress(act_it[ag], "%.")
				if act_arg[1] then
				if act_arg[2] ~= nil and tonumber(act_arg[2]) ~= nil then -- указано количество
					local ah = 0
					local count_i = tonumber(act_arg[2])
					while ah < count_i do
					table.insert(sub_tbl, act_arg[1])
					ah = ah + 1
					end
				else
					table.insert(sub_tbl, act_arg[1])
				end end
			ag = ag + 1
			end
			local NF = function()
				local A = assembly_dialogs.get_actor_params()
				local S = alife()
				for NFk, NFv in pairs(sub_tbl) do
					S:create(NFv, A.pos, A.lv, A.gv, A.id)
				end
			end
			_G.din_functions_dlg[string.format("%s%i_item", r_sec, r_k)] = NF
			phr_tbl[phr_k]:AddAction(string.format("din_functions_dlg.%s%i_item", r_sec, r_k))
		end
		if ltx:line_exist(r_sec, "remove"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "remove"..tostring(r_k)) 
			local act_it = assembly_dialogs.string_uncompress(act_s, ",")
			local ag = 1
			local sub_tbl = {}
			while act_it[ag] ~= nil do
				local act_arg = assembly_dialogs.string_uncompress(act_it[ag], "%.")
				if act_arg[1] then
				if act_arg[2] ~= nil and tonumber(act_arg[2]) ~= nil then -- указано количество
					
					table.insert(sub_tbl, {act_arg[1] , tonumber(act_arg[2])})
					
				else
					table.insert(sub_tbl, {act_arg[1] , 1})
				end end
			ag = ag + 1
			end
			local NF = function()
				local S = alife()
				for NFk, NFv in pairs(sub_tbl) do
					local have_t = assembly_dialogs.items_calc(NFv[1])
					local removed = 0
					for htk, htv in pairs(have_t) do
						if NFv[2] > removed then
							local sobj = S:object(htv)
							if sobj then
								S:release(sobj, true)
								removed = removed + 1
							end
						else
							break
						end
					end
				end
			end
			_G.din_functions_dlg[string.format("%s%i_remove", r_sec, r_k)] = NF
			phr_tbl[phr_k]:AddAction(string.format("din_functions_dlg.%s%i_remove", r_sec, r_k))
		end
		if ltx:line_exist(r_sec, "has_item"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "has_item"..tostring(r_k)) 
			local act_it = assembly_dialogs.string_uncompress(act_s, ",")
			local ag = 1
			local sub_tbl = {}
			while act_it[ag] ~= nil do
				local act_arg = assembly_dialogs.string_uncompress(act_it[ag], "%.")
				if act_arg[1] then
				if act_arg[2] ~= nil and tonumber(act_arg[2]) ~= nil then -- указано количество
					
					table.insert(sub_tbl, {act_arg[1] , tonumber(act_arg[2])})
					
				else
					table.insert(sub_tbl, {act_arg[1] , 1})
				end end
			ag = ag + 1
			end
			local NF = function()
				local R = true
				for NFk, NFv in pairs(sub_tbl) do --- все условия должны вернуть истину
					local have_t = assembly_dialogs.items_calc(NFv[1])
					if #have_t < NFv[2] then R = false break end
				end
				return R
			end
			_G.din_functions_dlg[string.format("%s%i_has_item", r_sec, r_k)] = NF
			phr_tbl[phr_k]:AddPrecondition(string.format("din_functions_dlg.%s%i_has_item", r_sec, r_k))
		end
		if ltx:line_exist(r_sec, "donthas_item"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "donthas_item"..tostring(r_k)) 
			local act_it = assembly_dialogs.string_uncompress(act_s, ",")
			local ag = 1
			local sub_tbl = {}
			while act_it[ag] ~= nil do
				local act_arg = assembly_dialogs.string_uncompress(act_it[ag], "%.")
				if act_arg[1] then
				if act_arg[2] ~= nil and tonumber(act_arg[2]) ~= nil then -- указано количество
					
					table.insert(sub_tbl, {act_arg[1] , tonumber(act_arg[2])})
					
				else
					table.insert(sub_tbl, {act_arg[1] , 1})
				end end
			ag = ag + 1
			end
			local NF = function()
				local R = true
				for NFk, NFv in pairs(sub_tbl) do --- все условия должны вернуть истину
					local have_t = assembly_dialogs.items_calc(NFv[1])
					if not (#have_t < NFv[2]) then R = false break end
				end
				return R
			end
			_G.din_functions_dlg[string.format("%s%i_donthas_item", r_sec, r_k)] = NF
			phr_tbl[phr_k]:AddPrecondition(string.format("din_functions_dlg.%s%i_donthas_item", r_sec, r_k))
		end
end

function assembly_first_phrase(r_sec, r_k, phr_tbl, phr_k, dlg)
	--printf(string.format("assembly_first_phrase %s, index %i", r_sec, r_k))
	phr_tbl[phr_k] = dlg:AddPhrase(ltx:r_string(r_sec, "x"..tostring(r_k)), def_0, def_none, -10000):GetPhraseScript()
		if ltx:line_exist(r_sec, "a"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "a"..tostring(r_k)) 
			local act_arg = assembly_dialogs.string_uncompress(act_s, ",")
			if type(act_arg) == "table" then
				local aa = 1
				while act_arg[aa] ~= nil do
					assembly_dialogs.exist_script_and_func(act_arg[aa], r_sec, r_k)
					phr_tbl[phr_k]:AddAction(act_arg[aa])
					aa = aa + 1
				end
			elseif type(act_arg) == "string" then
				assembly_dialogs.exist_script_and_func(act_arg, r_sec, r_k)
				phr_tbl[phr_k]:AddAction(act_arg)
			else
			 --- uncompatible types. Error.
			end
		end
		if ltx:line_exist(r_sec, "p"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "p"..tostring(r_k)) 
			local act_arg = assembly_dialogs.string_uncompress(act_s, ",")
			if type(act_arg) == "table" then
				local ab = 1
				while act_arg[ab] ~= nil do
					assembly_dialogs.exist_script_and_func(act_arg[ab], r_sec, r_k)
					phr_tbl[phr_k]:AddPrecondition(act_arg[ab])
					ab = ab + 1
				end
			elseif type(act_arg) == "string" then
				assembly_dialogs.exist_script_and_func(act_arg, r_sec, r_k)
				phr_tbl[phr_k]:AddPrecondition(act_arg)
			else
			 --- uncompatible types. Error.
			end
		end
		if ltx:line_exist(r_sec, "h"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "h"..tostring(r_k)) 
			local act_arg = assembly_dialogs.string_uncompress(act_s, ",")
			if type(act_arg) == "table" then
				local ac = 1
				while act_arg[ac] ~= nil do
					--assembly_dialogs.exist_script_and_func(act_arg[ac])
					phr_tbl[phr_k]:AddHasInfo(act_arg[ac])
					ac = ac + 1
				end
			elseif type(act_arg) == "string" then
				--assembly_dialogs.exist_script_and_func(act_arg)
				phr_tbl[phr_k]:AddHasInfo(act_arg)
			else
			 --- uncompatible types. Error.
			end
		end
		if ltx:line_exist(r_sec, "d"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "d"..tostring(r_k)) 
			local act_arg = assembly_dialogs.string_uncompress(act_s, ",")
			if type(act_arg) == "table" then
				local ad = 1
				while act_arg[ad] ~= nil do
					--assembly_dialogs.exist_script_and_func(act_arg[ad])
					phr_tbl[phr_k]:AddDontHasInfo(act_arg[ad])
					ad = ad + 1
				end
			elseif type(act_arg) == "string" then
				--assembly_dialogs.exist_script_and_func(act_arg)
				phr_tbl[phr_k]:AddDontHasInfo(act_arg)
			else
			 --- uncompatible types. Error.
			end
		end
		if ltx:line_exist(r_sec, "gi"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "gi"..tostring(r_k)) 
			local act_arg = assembly_dialogs.string_uncompress(act_s, ",")
			if type(act_arg) == "table" then
				local ae = 1
				while act_arg[ae] ~= nil do
					--assembly_dialogs.exist_script_and_func(act_arg[ae])
					phr_tbl[phr_k]:AddGiveInfo(act_arg[ae])
					ae = ae + 1
				end
			elseif type(act_arg) == "string" then
				--assembly_dialogs.exist_script_and_func(act_arg)
				phr_tbl[phr_k]:AddGiveInfo(act_arg)
			else
			 --- uncompatible types. Error.
			end
		end
		if ltx:line_exist(r_sec, "di"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "di"..tostring(r_k)) 
			local act_arg = assembly_dialogs.string_uncompress(act_s, ",")
			if type(act_arg) == "table" then
				local af = 1
				while act_arg[af] ~= nil do
					--assembly_dialogs.exist_script_and_func(act_arg[af])
					phr_tbl[phr_k]:AddDisafleInfo(act_arg[af])
					af = af + 1
				end
			elseif type(act_arg) == "string" then
				--assembly_dialogs.exist_script_and_func(act_arg)
				phr_tbl[phr_k]:AddDisableInfo(act_arg)
			else
			 --- uncompatible types. Error.
			end
		end
		if ltx:line_exist(r_sec, "item"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "item"..tostring(r_k)) 
			local act_it = assembly_dialogs.string_uncompress(act_s, ",")
			local ag = 1
			local sub_tbl = {}
			while act_it[ag] ~= nil do
				local act_arg = assembly_dialogs.string_uncompress(act_it[ag], "%.")
				if act_arg[1] then
				if act_arg[2] ~= nil and tonumber(act_arg[2]) ~= nil then -- указано количество
					local ah = 0
					local count_i = tonumber(act_arg[2])
					while ah < count_i do
					table.insert(sub_tbl, act_arg[1])
					ah = ah + 1
					end
				else
					table.insert(sub_tbl, act_arg[1])
				end end
			ag = ag + 1
			end
			local NF = function()
				local A = assembly_dialogs.get_actor_params()
				local S = alife()
				for NFk, NFv in pairs(sub_tbl) do
					S:create(NFv, A.pos, A.lv, A.gv, A.id)
				end
			end
			_G.din_functions_dlg[string.format("%s%i_item", r_sec, r_k)] = NF
			phr_tbl[phr_k]:AddAction(string.format("din_functions_dlg.%s%i_item", r_sec, r_k))
		end
		if ltx:line_exist(r_sec, "remove"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "remove"..tostring(r_k)) 
			local act_it = assembly_dialogs.string_uncompress(act_s, ",")
			local ag = 1
			local sub_tbl = {}
			while act_it[ag] ~= nil do
				local act_arg = assembly_dialogs.string_uncompress(act_it[ag], "%.")
				if act_arg[1] then
				if act_arg[2] ~= nil and tonumber(act_arg[2]) ~= nil then -- указано количество
					
					table.insert(sub_tbl, {act_arg[1] , tonumber(act_arg[2])})
					
				else
					table.insert(sub_tbl, {act_arg[1] , 1})
				end end
			ag = ag + 1
			end
			local NF = function()
				local S = alife()
				for NFk, NFv in pairs(sub_tbl) do
					local have_t = assembly_dialogs.items_calc(NFv[1])
					local removed = 0
					for htk, htv in pairs(have_t) do
						if NFv[2] > removed then
							local sobj = S:object(htv)
							if sobj then
								S:release(sobj, true)
								removed = removed + 1
							end
						else
							break
						end
					end
				end
			end
			_G.din_functions_dlg[string.format("%s%i_remove", r_sec, r_k)] = NF
			phr_tbl[phr_k]:AddAction(string.format("din_functions_dlg.%s%i_remove", r_sec, r_k))
		end
		if ltx:line_exist(r_sec, "has_item"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "has_item"..tostring(r_k)) 
			local act_it = assembly_dialogs.string_uncompress(act_s, ",")
			local ag = 1
			local sub_tbl = {}
			while act_it[ag] ~= nil do
				local act_arg = assembly_dialogs.string_uncompress(act_it[ag], "%.")
				if act_arg[1] then
				if act_arg[2] ~= nil and tonumber(act_arg[2]) ~= nil then -- указано количество
					
					table.insert(sub_tbl, {act_arg[1] , tonumber(act_arg[2])})
					
				else
					table.insert(sub_tbl, {act_arg[1] , 1})
				end end
			ag = ag + 1
			end
			local NF = function()
				local R = true
				for NFk, NFv in pairs(sub_tbl) do --- все условия должны вернуть истину
					local have_t = assembly_dialogs.items_calc(NFv[1])
					if #have_t < NFv[2] then R = false break end
				end
				return R
			end
			_G.din_functions_dlg[string.format("%s%i_has_item", r_sec, r_k)] = NF
			phr_tbl[phr_k]:AddPrecondition(string.format("din_functions_dlg.%s%i_has_item", r_sec, r_k))
		end
		if ltx:line_exist(r_sec, "donthas_item"..tostring(r_k)) then
			local act_s = ltx:r_string(r_sec, "donthas_item"..tostring(r_k)) 
			local act_it = assembly_dialogs.string_uncompress(act_s, ",")
			local ag = 1
			local sub_tbl = {}
			while act_it[ag] ~= nil do
				local act_arg = assembly_dialogs.string_uncompress(act_it[ag], "%.")
				if act_arg[1] then
				if act_arg[2] ~= nil and tonumber(act_arg[2]) ~= nil then -- указано количество
					
					table.insert(sub_tbl, {act_arg[1] , tonumber(act_arg[2])})
					
				else
					table.insert(sub_tbl, {act_arg[1] , 1})
				end end
			ag = ag + 1
			end
			local NF = function()
				local R = true
				for NFk, NFv in pairs(sub_tbl) do --- все условия должны вернуть истину
					local have_t = assembly_dialogs.items_calc(NFv[1])
					if not (#have_t < NFv[2]) then R = false break end
				end
				return R
			end
			_G.din_functions_dlg[string.format("%s%i_donthas_item", r_sec, r_k)] = NF
			phr_tbl[phr_k]:AddPrecondition(string.format("din_functions_dlg.%s%i_donthas_item", r_sec, r_k))
		end
end

function add_links_to_BD(section, id, outside_BD)
	--printf("add_links_to_BD")
	if not outside_BD[id] then
		outside_BD[id] = {}
	end
	local WD = outside_BD[id]
	local linkstring = ltx:r_string(section, "link"..tostring(id))
	local linkt = assembly_dialogs.string_uncompress(linkstring, ",")
	if type(linkt) ~= 'table' then linkt = {linkt} end
	local a = 1
	while linkt[a] ~= nil do
		local n = tonumber(linkt[a])
		table.insert(WD, {n, false})
		a = a + 1
	end
	outside_BD[id] = WD
end

function add_exit_links_to_BD(exit_links, section, r_k, outside_BD)
	--zander_log("add_exit_links_to_BD", "exit_links", exit_links, "section", section, "r_k", r_k, "outside_BD", outside_BD)
	--printf("add_exit_links_to_BD")
	local link_data = ltx:r_string(section, "link"..tostring(r_k))
	local link_t1 = assembly_dialogs.string_uncompress(link_data, "|")
	local target_links = {}
	--zander_log("link_t1", link_t1)
	for tk, tv in pairs(link_t1) do
		local t2 = assembly_dialogs.string_uncompress(tv, ",")
		target_links[tk] = t2
	end
	--zander_log("target_links", target_links)
	for k, v in pairs(target_links) do
		if exit_links[k] ~= nil then
			local from = exit_links[k]
			local to = {}
			for i, j in pairs(v) do
				table.insert(to, {tonumber(j), false})
			end
			outside_BD[from] = to
		else
			log1(string.format("Dialog %s; line %i: Число выходов диалогового блока недостаточно для подключаемых входов.", section, r_k))
			abort(string.format("Dialog %s; line %i: Число выходов диалогового блока недостаточно для подключаемых входов.", section, r_k))
		end
	end
end

function find_parent_link(self_id, outside_BD, sec)
	--printf("find_parent_link")
	--- функция устанавливает в найденном линке отметку, поэтому должна
	--- обязательно и сразу приводить к реальному созданию связи.
	local k1, k2 = nil, nil
	for k, v in pairs(outside_BD) do --- перебор исходящих адресов - у кого вообще есть линки куда-то
		for i, j in pairs(v) do --- перебор линков выбранного источника
			if j and j[1] == self_id and j[2] == false then
			--- найден линк на себя. и он еще не был использован.
			--- поставить метку об использовании, вернуть источник.
				k1 = k
				k2 = i
				break
			end
		end
		if k1 and k2 then
			break
		end
	end
	if k1 and k2 then
		local newvalue = {self_id, true}
		outside_BD[k1][k2] = newvalue
		return k1
	else
		return nil
	end
end

function construct_dlg_block(section, phr_tbl, phr_k, dlg, type_key, input_key) 
	--printf(string.format("construct_dlg_block %s", section))
	local inside_key = 1
	local lost_attempts = 0
	local inside_links = {}
	local block_links = {} -- источник - полный адрес. цель - номер в локальной сети.
	local exit_table = {}
	while ltx:line_exist(section, "x"..tostring(inside_key)) or lost_attempts < 100 do
		if ltx:line_exist(section, "x"..tostring(inside_key)) then
			-- добавляем фразу в диалог.
			if inside_key == 1 then -- это вход
				assembly_dialogs.assembly_phrase(section, inside_key, phr_tbl, phr_k, dlg, string.format("%s%i", type_key, inside_key), input_key)
				
			else -- это внутренняя фраза. необходимо вычислить входящий линк.
				local input_id = assembly_dialogs.find_parent_link(inside_key, inside_links, section)
				if input_id then
				assembly_dialogs.assembly_phrase(section, inside_key, phr_tbl, phr_k, dlg, string.format("%s%i", type_key, inside_key), string.format("%s%i", type_key, input_id))
				else
					input_id = assembly_dialogs.find_parent_link(inside_key, block_links, section)
					if input_id then
					assembly_dialogs.assembly_phrase(section, inside_key, phr_tbl, phr_k, dlg, string.format("%s%i", type_key, inside_key), input_id)
					else
						abort(string.format("Отсутствует входящий линк для фразы. section %s, phrase %i", section, inside_key))
					end
				end
			end
			--- сразу после добавления надо уже добавлять линки этой фразы.
				if ltx:line_exist(section, "link"..tostring(inside_key)) then
					assembly_dialogs.add_links_to_BD(section, inside_key, inside_links)
				end
				--- проверяем не является ли эта фраза одним из выходов блока.
				if ltx:line_exist(section, "exit"..tostring(inside_key)) then
					local n_exit = ltx:r_s32(section, "exit"..tostring(inside_key))
					exit_table[n_exit] = string.format("%s%i", type_key, inside_key)
				end
				phr_k = phr_k + 1
			lost_attempts = 0
		elseif ltx:line_exist(section, "block"..tostring(inside_key)) then
			--- вставить блок
			local block_input_key = assembly_dialogs.find_parent_link(inside_key, inside_links, section)
			if block_input_key then
				block_input_key = string.format("%s%i", type_key, block_input_key)
			else
				block_input_key = assembly_dialogs.find_parent_link(inside_key, block_links, section)
				if not block_input_key then
					log1(string.format("Отсутствует входящий линк для фразы. section %s, phrase %i", section, inside_key))
					abort(string.format("Отсутствует входящий линк для фразы. section %s, phrase %i", section, inside_key))
				end
			end
			local block_s = ltx:r_string(section, "block"..tostring(inside_key))
			local block_t = assembly_dialogs.string_uncompress(block_s, ",")
				-- выясним, адрес блока это секция конфига или имя функции?
				local block_at = assembly_dialogs.string_uncompress(block_t[1], "%.")
				local block_data = nil
				if type(block_at) == 'table' and block_at[2] ~= nil and block_at[2] ~= "" then
					--- это динамический блок
					assembly_dialogs.exist_script_and_func(block_t[1], section, inside_key)
					local dinb_a = block_at[1]
					local dinb_b = block_at[2]
					local dinb_F = _G[dinb_a][dinb_b]
					block_data = dinb_F(phr_tbl, phr_k, dlg, block_t[2], block_input_key)
					--- остается открытым вопрос, как передать туда данные.
					--- вариант: блоки, требующие дополнительных данных, ставить только внутри других скриптовых динамических
					--- блоков. скриптовые динамические блоки первого порядка не требуют дополнительных данных.
				else
					--- это линейный блок читаемый из конфигов
					block_data = assembly_dialogs.construct_dlg_block(block_t[1], phr_tbl, phr_k, dlg, block_t[2], block_input_key)
			
				end
				if not block_data and block_data[a] and block_data[2] then
					log1(string.format("Некорректное формирование блока, данные для соединения с диалогом отсутствуют. section %s, phrase %i", section, inside_key))
					abort(string.format("Некорректное формирование блока, данные для соединения с диалогом отсутствуют. section %s, phrase %i", section, inside_key))
				end
			phr_k = block_data[1]
			local exit_links = block_data[2]
			if ltx:line_exist(section, "link"..tostring(inside_key)) then
				assembly_dialogs.add_exit_links_to_BD(exit_links, section, inside_key, block_links)
			end
		else
			lost_attempts = lost_attempts + 1
		end
		--- тут проверять наличие других ключей-команд. выход например.
		inside_key = inside_key + 1
	end
	--- после завершения формирования реальных фраз, надо обработать массив дополнительных линков.
	phr_k = assembly_dialogs.final_link_BD(inside_key, inside_links, phr_tbl, phr_k, dlg, type_key)
	phr_k = assembly_dialogs.final_blocklink_BD(block_links, phr_tbl, phr_k, dlg, type_key)
	return {phr_k, exit_table}
	--- возвращаем следующий свободный ид в таблице фраз, и таблицу полных ид фраз, являющихся выходами данного блока.
end

function final_link_BD(find_size, outside_BD, phr_tbl, phr_k, dlg, type_key)
	--printf("final_link_BD")
	--zander_log({find_size, outside_BD, phr_tbl, phr_k, dlg, type_key})
	local aln = 1
	while aln < find_size do
	---log("ztdialg: circular trace... "..tostring(aln))
		input_table = outside_BD[aln]
		if input_table then
		for k, v in pairs(input_table) do
			if v[2] == false then
				--printf(string.format("add link... %s%i >>> %s%i", type_key, aln, type_key, v[1]))
				phr_tbl[phr_k] = dlg:AddPhrase("", dia(string.format("%s%i", type_key, v[1])), dia(string.format("%s%i", type_key, aln)), 0)
				phr_k = phr_k + 1
			end
		end end
	aln = aln + 1
	end
	return phr_k
end

function final_blocklink_BD(outside_BD, phr_tbl, phr_k, dlg, type_key)
	--printf("final_blocklink_BD")
	for k, v in pairs(outside_BD) do
		for i, j in pairs(v) do
			if j[2] == false then
				--printf("add link... %s >>> %s%i", k, type_key, j[1])
				phr_tbl[phr_k] = dlg:AddPhrase("", dia(string.format("%s%i", type_key, j[1])), dia(k), 0)
				phr_k = phr_k + 1
			end
		end
	end
	return phr_k
end

function act_npc_control_init(dialog_type)
	act_npc_phrases = {}
	if dialog_type == "actor" then
		act_npc_phrases["def_0"] = "actor"
		act_npc_control_status = true
	elseif dialog_type == "npc" then
		act_npc_phrases["def_0"] = "npc"
		act_npc_control_status = true
	elseif dialog_type == "free" then
		act_npc_control_status = false -- не отслеживать чередование
	else
		log1("Warning! sequence monitoring is not performed. data incorrect.")
		act_npc_control_status = false
	end
end

function act_npc_control_system(phrase_id, input_id, sec, line)
	if act_npc_control_status then
		local in_id
		if input_id == def_0 then in_id = "def_0" else in_id = input_id end
		local input_speaker = act_npc_phrases[in_id]
		if input_speaker then
			local self_speaker = act_npc_phrases[phrase_id]
			if input_speaker == "actor" then
				if self_speaker then
					if self_speaker ~= "npc" then
						log1(string.format("Нарушено чередование фраз npc/actor. section %s, line %i", sec, line))
						abort(string.format("Нарушено чередование фраз npc/actor. section %s, line %i", sec, line))
					end
				else
					act_npc_phrases[phrase_id] = "npc"
				end
			elseif input_speaker == "npc" then
				if self_speaker then
					if self_speaker ~= "actor" then
						log1(string.format("Нарушено чередование фраз npc/actor. section %s, line %i", sec, line))
						abort(string.format("Нарушено чередование фраз npc/actor. section %s, line %i", sec, line))
					end
				else
					act_npc_phrases[phrase_id] = "actor"
				end
			else
				log1("Warning! sequence monitoring is not performed. data missed.")
				act_npc_control_status = false
			end
		else
			log1("Warning! sequence monitoring is not performed. data missed.")
			act_npc_control_status = false
		end
	end
end

function construct_dialog(section, dlg)
	if not init_complete then
	assembly_dialogs.init()
	end
	assembly_dialogs.diaclear()
	log1(string.format("construct dialog %s", section))

	local phr_tbl = {}
	local phr_k = 1
	local type_key = nil
	if ltx:line_exist(section, "params_keyname") then
		type_key = ltx:r_string(section, "params_keyname")
	else
		type_key = section.."type_key"
	end
	if ltx:line_exist(section, "params_sequence") then
		local type_sequence = ltx:r_string(section, "params_sequence")
		assembly_dialogs.act_npc_control_init(type_sequence)
	else
		assembly_dialogs.act_npc_control_init("actor")
	end
	assembly_dialogs.assembly_first_phrase(section, 0, phr_tbl, phr_k, dlg)
	
		local inside_key = 1
	local lost_attempts = 0
	local inside_links = {}
	local block_links = {} -- источник - полный адрес. цель - номер в локальной сети.
	
	while ltx:line_exist(section, "x"..tostring(inside_key)) 
	or ltx:line_exist(section, "block"..tostring(inside_key))
	or lost_attempts < 100 do
		if ltx:line_exist(section, "x"..tostring(inside_key)) then
			-- добавляем фразу в диалог.
			if inside_key == 1 then -- это вход
				assembly_dialogs.assembly_phrase(section, inside_key, phr_tbl, phr_k, dlg, string.format("%s%i", type_key, inside_key), nil)
				
			else -- это внутренняя фраза. необходимо вычислить входящий линк.
				local input_id = assembly_dialogs.find_parent_link(inside_key, inside_links, section)
				if input_id then
				assembly_dialogs.assembly_phrase(section, inside_key, phr_tbl, phr_k, dlg, string.format("%s%i", type_key, inside_key), string.format("%s%i", type_key, input_id))
				else
					input_id = assembly_dialogs.find_parent_link(inside_key, block_links, section)
					if input_id then
					assembly_dialogs.assembly_phrase(section, inside_key, phr_tbl, phr_k, dlg, string.format("%s%i", type_key, inside_key), input_id)
					else
						log1(string.format("Отсутствует входящий линк для фразы. section %s, phrase %i", section, inside_key))
						abort(string.format("Отсутствует входящий линк для фразы. section %s, phrase %i", section, inside_key))
					end
				end
			end
			--- сразу после добавления надо уже добавлять линки этой фразы.
				if ltx:line_exist(section, "link"..tostring(inside_key)) then
					assembly_dialogs.add_links_to_BD(section, inside_key, inside_links)
				end
				
				phr_k = phr_k + 1
			lost_attempts = 0
		elseif ltx:line_exist(section, "block"..tostring(inside_key)) then
			--- вставить блок
			local block_input_key = assembly_dialogs.find_parent_link(inside_key, inside_links, section)
			if block_input_key then
				block_input_key = string.format("%s%i", type_key, block_input_key)
			else
				block_input_key = assembly_dialogs.find_parent_link(inside_key, block_links, section)
				if not block_input_key then
					log1(string.format("Отсутствует входящий линк для фразы. section %s, phrase %i", section, inside_key))
					abort(string.format("Отсутствует входящий линк для фразы. section %s, phrase %i", section, inside_key))
				end
			end
			local block_s = ltx:r_string(section, "block"..tostring(inside_key))
			local block_t = assembly_dialogs.string_uncompress(block_s, ",")
				-- выясним, адрес блока это секция конфига или имя функции?
				local block_at = assembly_dialogs.string_uncompress(block_t[1], "%.")
				local block_data = nil
				if type(block_at) == 'table' and block_at[2] ~= nil and block_at[2] ~= "" then
					--- это динамический блок
					assembly_dialogs.exist_script_and_func(block_t[1], section, inside_key)
					local dinb_a = block_at[1]
					local dinb_b = block_at[2]
					local dinb_F = _G[dinb_a][dinb_b]
					block_data = dinb_F(phr_tbl, phr_k, dlg, block_t[2], block_input_key)
					--- остается открытым вопрос, как передать туда данные.
					--- вариант: блоки, требующие дополнительных данных, ставить только внутри других скриптовых динамических
					--- блоков. скриптовые динамические блоки первого порядка не требуют дополнительных данных.
				else
					--- это линейный блок читаемый из конфигов
					block_data = assembly_dialogs.construct_dlg_block(block_t[1], phr_tbl, phr_k, dlg, block_t[2], block_input_key)
			
				end
			phr_k = block_data[1]
			local exit_links = block_data[2]
			if ltx:line_exist(section, "link"..tostring(inside_key)) then
				
				if not (block_data and block_data[1] and block_data[2]) then
					log1(string.format("Некорректное формирование блока, данные для соединения с диалогом отсутствуют. section %s, phrase %i", section, inside_key))
					abort(string.format("Некорректное формирование блока, данные для соединения с диалогом отсутствуют. section %s, phrase %i", section, inside_key))
				end
				
				printf("read link"..tostring(inside_key))
				assembly_dialogs.add_exit_links_to_BD(exit_links, section, inside_key, block_links)
				
			end
		else
			lost_attempts = lost_attempts + 1
		end
		inside_key = inside_key + 1
	end
	--- после завершения формирования реальных фраз, надо обработать массив дополнительных линков.
	phr_k = assembly_dialogs.final_link_BD(inside_key, inside_links, phr_tbl, phr_k, dlg, type_key)
	phr_k = assembly_dialogs.final_blocklink_BD(block_links, phr_tbl, phr_k, dlg, type_key)
	local msg = string.format("Dialog Assembled. Section %s, %i phrase by generated.", section, phr_k)
	--printf(msg)
	--news_manager.send_tip(db.actor, msg, nil, nil, 10000)
end

function assembly_phrase_ex(text, phr_tbl, phr_k, dlg, phrase_key, input_key, a_tbl, p_tbl)
	printf(string.format("assembly_phrase %s, index %i, out: %s; in^ %s", text, phr_k, phrase_key, input_key or "0"))
	local ik = nil
	if input_key then ik = dia(input_key)
	else ik = def_0 end
	local self_phr_key = assembly_dialogs.dia(phrase_key)
	assembly_dialogs.act_npc_control_system(self_phr_key, ik, "no data", -1)
	--zander_log("ALALA1", phr_tbl, "ALALA2", phr_k, "ALALA3", text, "self_phr_key", self_phr_key, "ik", ik)
	phr_tbl[phr_k] = dlg:AddPhrase(text, self_phr_key, ik, -10000):GetPhraseScript()

				local aa = 1
				while a_tbl[aa] ~= nil do
					assembly_dialogs.exist_script_and_func(a_tbl[aa], phrase_key, -1)
					phr_tbl[phr_k]:AddAction(a_tbl[aa])
					aa = aa + 1
				end

				local ab = 1
				while p_tbl[ab] ~= nil and p_tbl[ab] ~= "" do
					assembly_dialogs.exist_script_and_func(p_tbl[ab], phrase_key, -1)
					phr_tbl[phr_k]:AddPrecondition(p_tbl[ab])
					ab = ab + 1
				end
end

function AddPHR(text, phr_tbl, phr_k, dlg, phrase_key, input_key, command_tbl)
	--- полный набор команд для формирования фраз, на стороне скриптов.
		local ik = nil
	if input_key then ik = dia(input_key)
	else ik = def_0 end
	local self_phr_key = assembly_dialogs.dia(phrase_key)
	assembly_dialogs.act_npc_control_system(self_phr_key, ik, "no data", -1)
	phr_tbl[phr_k] = dlg:AddPhrase(text, self_phr_key, ik, -10000):GetPhraseScript()
	
		if command_tbl.a then
			local act_arg = command_tbl.a
				local aa = 1
				while act_arg[aa] ~= nil do
					assembly_dialogs.exist_script_and_func(act_arg[aa], r_sec, r_k)
					phr_tbl[phr_k]:AddAction(act_arg[aa])
					aa = aa + 1
				end
		end
		if command_tbl.p then
			local act_arg = command_tbl.p
				local ab = 1
				while act_arg[ab] ~= nil and act_arg[ab] ~= "" do
					assembly_dialogs.exist_script_and_func(act_arg[ab], r_sec, r_k)
					phr_tbl[phr_k]:AddPrecondition(act_arg[ab])
					ab = ab + 1
				end
		end
		if command_tbl.h then
			local act_arg = command_tbl.h
				local ac = 1
				while act_arg[ac] ~= nil do
					--assembly_dialogs.exist_script_and_func(act_arg[ac])
					phr_tbl[phr_k]:AddHasInfo(act_arg[ac])
					ac = ac + 1
				end
		end
		if command_tbl.d then
			local act_arg = command_tbl.d
				local ad = 1
				while act_arg[ad] ~= nil do
					--assembly_dialogs.exist_script_and_func(act_arg[ad])
					phr_tbl[phr_k]:AddDontHasInfo(act_arg[ad])
					ad = ad + 1
				end
		end
		if command_tbl.gi then
			local act_arg = command_tbl.gi
				local ae = 1
				while act_arg[ae] ~= nil do
					--assembly_dialogs.exist_script_and_func(act_arg[ae])
					phr_tbl[phr_k]:AddGiveInfo(act_arg[ae])
					ae = ae + 1
				end
		end
		if command_tbl.di then
			local act_arg = command_tbl.di
				local af = 1
				while act_arg[af] ~= nil do
					--assembly_dialogs.exist_script_and_func(act_arg[af])
					phr_tbl[phr_k]:AddDisafleInfo(act_arg[af])
					af = af + 1
				end
		end
		if command_tbl.item then
			local act_it = command_tbl.item
			local ag = 1
			local sub_tbl = {}
			while act_it[ag] ~= nil do
				local act_arg = assembly_dialogs.string_uncompress(act_it[ag], "%.")
				if act_arg[1] then
				if act_arg[2] ~= nil and tonumber(act_arg[2]) ~= nil then -- указано количество
					local ah = 0
					local count_i = tonumber(act_arg[2])
					while ah < count_i do
					table.insert(sub_tbl, act_arg[1])
					ah = ah + 1
					end
				else
					table.insert(sub_tbl, act_arg[1])
				end end
			ag = ag + 1
			end
			if #sub_tbl > 0 then
			local NF = function()
				local A = assembly_dialogs.get_actor_params()
				local S = alife()
				for NFk, NFv in pairs(sub_tbl) do
					S:create(NFv, A.pos, A.lv, A.gv, A.id)
				end
			end
			_G.din_functions_dlg[string.format("%s_item", phrase_key)] = NF
			phr_tbl[phr_k]:AddAction(string.format("din_functions_dlg.%s_item", phrase_key))
			end
		end
		if command_tbl.remove then
			local act_it = command_tbl.remove
			local ag = 1
			local sub_tbl = {}
			while act_it[ag] ~= nil do
				local act_arg = assembly_dialogs.string_uncompress(act_it[ag], "%.")
				if act_arg[1] then
				if act_arg[2] ~= nil and tonumber(act_arg[2]) ~= nil then -- указано количество
					
					table.insert(sub_tbl, {act_arg[1] , tonumber(act_arg[2])})
					
				else
					table.insert(sub_tbl, {act_arg[1] , 1})
				end end
			ag = ag + 1
			end
			if #sub_tbl > 0 then
			local NF = function()
				local S = alife()
				for NFk, NFv in pairs(sub_tbl) do
					local have_t = assembly_dialogs.items_calc(NFv[1])
					local removed = 0
					for htk, htv in pairs(have_t) do
						if NFv[2] > removed then
							local sobj = S:object(htv)
							if sobj then
								S:release(sobj, true)
								removed = removed + 1
							end
						else
							break
						end
					end
				end
			end
			_G.din_functions_dlg[string.format("%s_remove", phrase_key)] = NF
			phr_tbl[phr_k]:AddAction(string.format("din_functions_dlg.%s_remove", phrase_key))
			end
		end
		if command_tbl.has_item then
			local act_it = command_tbl.has_item
			local ag = 1
			local sub_tbl = {}
			while act_it[ag] ~= nil do
				local act_arg = assembly_dialogs.string_uncompress(act_it[ag], "%.")
				if act_arg[1] then
				if act_arg[2] ~= nil and tonumber(act_arg[2]) ~= nil then -- указано количество
					
					table.insert(sub_tbl, {act_arg[1] , tonumber(act_arg[2])})
					
				else
					table.insert(sub_tbl, {act_arg[1] , 1})
				end end
			ag = ag + 1
			end
			if #sub_tbl > 0 then
			local NF = function()
				local R = true
				for NFk, NFv in pairs(sub_tbl) do --- все условия должны вернуть истину
					local have_t = assembly_dialogs.items_calc(NFv[1])
					if #have_t < NFv[2] then R = false break end
				end
				return R
			end
			_G.din_functions_dlg[string.format("%s_has_item", phrase_key)] = NF
			phr_tbl[phr_k]:AddPrecondition(string.format("din_functions_dlg.%s_has_item", phrase_key))
			end
		end
		if command_tbl.donthas_item then
			local act_it = command_tbl.donthas_item
			local ag = 1
			local sub_tbl = {}
			while act_it[ag] ~= nil do
				local act_arg = assembly_dialogs.string_uncompress(act_it[ag], "%.")
				if act_arg[1] then
				if act_arg[2] ~= nil and tonumber(act_arg[2]) ~= nil then -- указано количество
					
					table.insert(sub_tbl, {act_arg[1] , tonumber(act_arg[2])})
					
				else
					table.insert(sub_tbl, {act_arg[1] , 1})
				end end
			ag = ag + 1
			end
			if #sub_tbl > 0 then
			local NF = function()
				local R = true
				for NFk, NFv in pairs(sub_tbl) do --- все условия должны вернуть истину
					local have_t = assembly_dialogs.items_calc(NFv[1])
					if not (#have_t < NFv[2]) then R = false break end
				end
				return R
			end
			_G.din_functions_dlg[string.format("%s_donthas_item", phrase_key)] = NF
			phr_tbl[phr_k]:AddPrecondition(string.format("din_functions_dlg.%s_donthas_item", phrase_key))
			end
		end
	
end

local phrasedialog_profiles = {

}
function set_profile_data(profile, data)
	phrasedialog_profiles[profile] = data
end
function get_profile_data(profile)
	return phrasedialog_profiles[profile]
end

function Generic_block_question_to_npc(dlgdata, setgs)
	--[[
		Блок имитирует разнообразие ответов нпс на вопросы ГГ.
		Структура:
		Актор		НПС
		(Вопрос) 		(ответ 1)
					(ответ 2)...
		
		Для актора на самом деле формируется энное число фраз, с одним и тем же текстом вопроса. Доступна будет одна из них.
		Какой будет дан ответ на вопрос, определяется до того как вопрос будет задан. Однако игрок ответа не знает.
		До запуска блока, должна быть сгенерирована таблица доступа по профилю (см. set_profile_data)
		cdвоего рода "оперативная память" диалога. в нее заносится число, являющееся вариантом ответа, на вопрос в случае если он будет задан.
		Таким образом, для актора станет доступна из этого блока единственная фраза с этим вопросом, и предопределяющая 
		требуемый ответ нпс.
	]]
local profile, actortext, count, npcreplyes, actions, mode = setgs[1], setgs[2], setgs[3], setgs[4], setgs[5], setgs[6]
local phr_tbl, phr_k, dlg, block_name, block_input_key = dlgdata[1], dlgdata[2], dlgdata[3], dlgdata[4], dlgdata[5]
-- assembly_phrase_ex(text, phr_tbl, phr_k, dlg, phrase_key, input_key, a_tbl, p_tbl)
	local a = 1
	local e_table = {}
	while a < (count + 1) do
		local xxx = a
		local F = function()
			return assembly_dialogs.get_profile_data(profile) == xxx
		end
		_G.din_functions_dlg[string.format("%s_%i_access", profile, xxx)] = F
		local a_phr_key = string.format("%s_a_%i", block_name, xxx)
		local p_tbl = {
			[1] = string.format("din_functions_dlg.%s_%i_access", profile, xxx)
		}
		assembly_dialogs.assembly_phrase_ex(actortext, phr_tbl, phr_k, dlg, a_phr_key, block_input_key, {}, p_tbl)
		phr_k = phr_k + 1
		local npc_phr_key = string.format("%s_b_%i", block_name, xxx)
		assembly_dialogs.assembly_phrase_ex(npcreplyes[xxx], phr_tbl, phr_k, dlg, npc_phr_key, a_phr_key, actions[xxx] or {}, {})
		phr_k = phr_k + 1
		table.insert(e_table, npc_phr_key)
	a = a + 1
	end
	if mode == 1 then
		--- свести все выходы в одну фразу
		local exit_id = string.format("%s_e", block_name)
		for k, v in pairs(e_table) do
			phr_tbl[phr_k] = dlg:AddPhrase("", assembly_dialogs.dia(exit_id), assembly_dialogs.dia(v), 0)
			phr_k = phr_k + 1
		end
		phr_tbl[phr_k] = dlg:AddPhrase("", assembly_dialogs.dia(exit_id.."nd"), assembly_dialogs.dia(exit_id), 0)
		phr_k = phr_k + 1
		return {phr_k, {exit_id.."nd"}}
	else
		--- вернуть все варианты ответа в качестве выходов.
		return {phr_k, e_table}
	end
--[[
		table.insert(exit_table, phrg_id)
		return {phr_k, exit_table}
	--- возвращаем следующий свободный ид в таблице фраз, и таблицу полных ид фраз, являющихся выходами данного блока.
]]
end

function test_generic_question(phr_tbl, phr_k, dlg, block_name, block_input_key)
	local d_set = {phr_tbl, phr_k, dlg, block_name, block_input_key}
	local mode_set = {
		[1] = "test_profile", 
		[2] = "test_question", 
		[3] = 4, 
		[4] = {
			"que_1", "que_2", "que_3", "que_4"
		}, 
		[5] = {}, 
		[6] = 1
	}
	return assembly_dialogs.Generic_block_question_to_npc(d_set, mode_set)
end

function test_run()
	assembly_dialogs.set_profile_data("test_profile", math.random(1,4))
end

